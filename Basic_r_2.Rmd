---
title: "Basic Concepts in R - Types of Data"
description: |
#   A new article created using the Distill format.
author:
  - name: Tehilla Ostrovsky 
#     url: https://example.com/norajones
#     affiliation: Spacely Sprockets
#     affiliation_url: https://example.com/spacelysprokets
date: "`r Sys.Date()`"
output: distill::distill_article
---

## This session, we'll explore the evolution of data structures, from the simplest building block to the versatile and powerful lists. 

This is going to be a useful guide for beginners looking to grasp the basics in programming, join us on this educational journey.

## In this blog post, we will explore:

<span style="color: red;">
1. Creating and Working with Vectors:</span> How to declare and manipulate vectors to store data efficiently.

<span style="color: red;">
2. Binding Data:</span> Techniques for combining vectors into larger datasets, including cbind and rbind.

<span style="color: red;">
3. Matrices in Action:</span> Practical examples of using matrices for numerical operations and data analysis.

<span style="color: red;">
4. Unlocking the Power of Lists:</span> An in-depth exploration of lists, including creating, modifying, and navigating through nested lists.

<span style="color: red;">
5. Real-World Use Cases:</span> Demonstrations of how these data structures are applied in programming and data analysis.


# Single Values: The Foundation

In our last blog post, we discussed objects in R that were assigned a single value, whether factor type (e.g., your name or gender) or a numerical value such as a = 1 or a logical type (e.g., rain_tomorrow = FALSE). These single values serve as the building blocks of more complex data structures. They represent individual pieces of information and can take on various data types, depending on the context.

Here's a brief recap:

1. **Factor Values**: Factors are used to represent categorical data with distinct levels. 

For example, you might have a factor variable for "gender" with levels "Male," "Female," and "Non-binary."

2. **Numerical Values**: Numerical values are used for storing numeric data, such as integers or floating-point numbers. 

They allow you to perform mathematical operations and calculations.


3. **Logical Values**: Logical values, often represented as TRUE or FALSE, are used to handle binary decisions or conditions. 

They are essential for control flow and conditional statements in programming.

```{r}
# Single value examples
age <- 30
name <- "John"
temperature <- 25.5

# Printing single values
cat("Name:", name, "\n")
cat("Age:", age, "\n")
cat("Temperature:", temperature, "\n")
```


<span style="color: red;"> These single values are versatile and useful on their own, but as we venture further into data manipulation and analysis, we'll discover how they can be combined and structured into more complex data structures like vectors, matrices, and lists.</span>

# Indexing in R: Navigating Your Data
Before we dive into the world of vectors, it's essential to understand the concept of indexing in R. 

Indexing allows us to access specific elements within data structures, such as vectors, matrices, and lists. 

Think of indexing as a way to pinpoint and retrieve exactly what you need from your data.

In R, indexing starts at 1, which means the first element in a data structure is accessed using index 1, the second element with index 2, and so on. 

Additionally, negative indices can be used to exclude elements from a data structure, and logical vectors can be used to filter elements based on certain conditions.

Here's a brief overview of indexing in R:

1. **Single Indexing**: Access a single element using its position in the data structure.

```{r}
my_vector <- c("apple", "banana", "cherry")
print(my_vector[2])  # Accesses the second element, "banana"
```

2. **Multiple Indexing**: Access multiple elements by specifying a vector of indices.

```{r}
my_vector <- c("apple", "banana", "cherry")
indices <- c(1, 3)
print(my_vector[indices])  # Accesses the first and third elements, "apple" and "cherry"
```


3. **Negative Indexing**: Exclude elements using negative indices.

```{r}
my_vector <- c("apple", "banana", "cherry")
print(my_vector[-2])  # Excludes the second element, "banana"
```


4. **Logical Indexing**: Filter elements based on logical conditions.

```{r}
my_vector <- c(10, 20, 30, 40, 50)
condition <- my_vector > 25
print(my_vector[condition])  # Selects elements greater than 25, i.e., 30, 40, and 50
```

#### Now that we have a good grasp of indexing, let's explore the world of vectors and see how indexing plays a crucial role in working with them effectively.

# Vectors: Bridging the Gap

Enter vectors, an array-like structure that allows us to store multiple single values of the same data type within a single variable. 

Vectors provide a seamless way to work with lists of data, enabling us to perform operations on them collectively.


```{r}
# Creating vectors
numbers <- c(1, 2, 3, 4, 5)
fruits <- c("apple", "banana", "cherry")

# Accessing elements of a vector
print(numbers[2])    # Prints the second element (2)
print(fruits[3])     # Prints "cherry"
```

# Matrices: Two-Dimensional Arrays

Matrices are the next step in our journey. 

These two-dimensional data structures consist of rows and columns, providing a structured way to represent data. 

Matrices are especially useful for numerical computations, statistical analysis, and linear algebra.

```{r}
# Combining vectors using cbind and rbind
vector1 <- c(1, 2, 3)
vector2 <- c("A", "B", "C")

# Combining by columns (cbind)
combined_col <- cbind(vector1, vector2)

# Combining by rows (rbind)
combined_row <- rbind(vector1, vector2)

print(combined_col)
print(combined_row)
```


```{r}
# Creating matrices
matrix1 <- matrix(1:6, nrow = 2, ncol = 3)  # 2x3 matrix
matrix2 <- matrix(c(7, 8, 9), nrow = 3, ncol = 1)  # 3x1 matrix

# Matrix multiplication
result_matrix <- matrix1 %*% matrix2

print(matrix1)
print(matrix2)
print(result_matrix)
```



```{r}
# Creating lists
student1 <- list(name = "Alice", age = 22, grades = c(85, 90, 78))
student2 <- list(name = "Bob", age = 24, grades = c(76, 88, 92))

# Creating a list of students
students <- list(student1, student2)

# Accessing elements of a list
print(students[[1]]$name)  # Accessing the name of the first student
print(students[[2]]$grades)  # Accessing the grades of the second student
```



# Lists: The Ultimate Data Structure

Finally, we arrive at the pinnacle of data structures: lists. 

Lists are versatile collections that can store heterogeneous data types, including vectors, matrices, and even other lists. 

They allow us to create complex, nested data structures, making them invaluable in data analysis, data manipulation, and managing large-scale projects.
